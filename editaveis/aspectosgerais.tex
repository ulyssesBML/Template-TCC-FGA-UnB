\chapter*[Introdução]{Introdução}
\addcontentsline{toc}{chapter}{Introdução}

O conceito de computação em nuvem está difundido como um novo paradigma para o desenvolvimento de sistemas, esse paradigma propõe a execução e o armazenamento através da internet sem a necessidade de programas no sistema local.

Uma das abordagens adotadas pela programação em nuvem é o Infrastructure as a service ou Infraestrutura como um serviço (IaaS), essa designação é feita para  definir um serviço executado na nuvem, que é feito através de máquinas virtuais que rodam nos clusters das empresas que disponibilizam esse serviço.

Um dos problema enfrentado por essas empresas é impacto financeiro e ambiental por deixar as máquinas ligadas, já que o custo elétrico delas pode se mostrar elevados pela grande quantidade de clusters ligados.

Nessa perspectiva uma das grandes áreas de busca dessas empresas é a consolidação de máquinas virtuais onde essa visa a minimização de máquinas ligadas, para isso várias limitações físicas devem ser levados em consideração como a quantidade de memória ram, processamento, barramento da internet, dentre outras que se apresentam em determinados contextos.

O objeto de estudo desse trabalho tende a se inclinar para o estudo dos recursos de processamento e ram e de conflitos entre maquinas virtuais, pois esses consolidam os problemas mais pertinentes na consolidação de maquinas virtuais.


\chapter{Problemática}

Para abranger a problemática envolvida na consolidação de maquinas virtuais deve se levar em conta os limites físicos e as regras estabelecidas no contexto das empresas abordando soluções que não penalizem a qualidade do serviço.

Para alcançar a consolidação de maquinas virtuais foi feita a analise do problema em duas parte uma visando a melhor alocação dos recursos físicos e outra corrigindo conflitos que essa alocação possa acarretar. 

\section{Recursos Físicos}

O problema da má gestão dos recursos físicos é um problema encontrado em grande partes da empresas, e como vantagem competitiva a optimização desses recursos pode alavancar em uma possível disputa empresarial.

No caso das empresas que prestam infraestrutura como um serviço, um dos objetos de maior desperdício será o processamento e a memoria de seus equipamentos, ja que uma alocação mal feita gerara espaços produz irar espaços vazios que poderiam ser utilizados para prover mais serviços.

Com a tecnologia atual dos computadores a má alocação em vista do consumo de energia foi minimizadas, fazendo com que uma maquina lotada e uma vazia gastem uma quantidade similar de energia, porem mesmo com essas melhorias, uma maquina inativa sempre consumira menos energia que uma ligada, portanto o problema da optimização persiste porem com o intuito de atribuir o máximo de serviço a menor quantidade de maquinas, para que assim haja uma economia inativando maquinas desnecessárias.

\section{Afinidade Entre Aplicações}

O problema de afinidade entre aplicações é um problema que afeta diretamente a solução de gerenciar os recursos físicos, esse problema consiste em aplicações que disputam algum recurso da maquina física, o que acarreta danos para aplicação de velocidade ou ate mesmo de indisponibilidade.

No caso do escopo do tópico 1.1 o problema se intensifica pois uma solução seria colocar o máximo numero de maquinas virtuais em menos recurso físicos ativos, porem isso aumenta a probabilidade que ocorra uma distribuição em que maquinas disputem os recursos.

\section{Conclusão}

Para que a consolidação das maquinas virtuais seja efetivada deve se considerar os dois principais problemas relatados, pois a solução baseada só em uma delas acarretaria em uma solução que prejudicaria a qualidade do serviços, o que não mostraria uma solução de viés satisfatória para a industria.
 
\chapter{Background}

Essa sessão é destinado ao levantamento teórico da solução proposta para o problema.

\section{Logica Proposicional}

A logica proposicional é um sistema destinado para a representação de proposições e sentenças declarativas, que podem possuir valores verdadeiros ou falsos.

Uma logica proposicional possui regras estabelecidas para sua formulação onde é utilizado conectivos lógicos para seu desenvolvimento esses conectivos permitidos são $\land$ (e), $\lor$ (ou), $\lnot$ (negação), $\Rightarrow$ (se...então), $\iff$ (se e somente se). Através desses podemos construir sentenças compostas que são elaboradas através da junção de sentenças com os conectores mencionados, dando assim a possibilidade da representação de expressões logicas mais complexas.


\section{SAT}

A Satisfatibilidade Booleana ou SAT é um problema da classe dos NP-completos que dado uma expressão lógica com variáveis booleanas ele tenta determinar um o conjunto de variáveis que ao serem verdadeiras o valor da expressão também é verdadeiro.

Nesses quesitos quando a formulação é dita como satisfeita é quando ocorre que o conjunto da formulação é dado como verdadeiro, e não satisfeita quando é falso. 
 


Exemplo:
 
Dado as variáveis x1, x2 na expressão lógica $y = x1 \land x2$

\begin{center}
\begin{tabular}{ |c|c|c|c| } 
\hline
x1 & x2 & y & tipo\\
\hline
0 & 0  & 0 & solução não satisfeita \\ 
0 & 1 & 0  & solução não satisfeita \\ 
1 & 0 & 0  & solução não satisfeita \\
1 & 1 & 1  & solução satisfeita \\
\hline
\end{tabular}
\end{center}

\subsection{Resolvedores SAT}

Os resolvedores SAT são programas especializados em encontrar soluções satisfatórias para uma logica Proposicional, ele utiliza de métodos avançados para uma resolução rapida do algoritmo, o que é vital para logica sat por ser um problema NP-completo.

\section{Pseudo Boolean}

As funções pseudo-booleanas tem intuito de realizar o mapeamento de valores booleanos para números reais, isso ocorre através do uso de variáveis booleanas junto a restrições de desigualdade linear com coeficientes inteiros que agem como um peso nas variáveis booleanas.
	
A vantagem do uso das funções pseudo booleanas esta na facilidade de abstração de problemas através das restrições pseudo booleanas, e por sua proximidade com SAT pode ser resolvida polinomialmente com o uso de SAT solvers.  

\chapter[Trabalhos Correlatos]{Trabalhos Correlatos}

Esse capitulo visa dissecar e compreender os trabalhos que servem como base para o desenvolvimento desse projeto.

Pela a proposta de resolução do problema se basear em técnicas pseudo-booleanas e optimização por restrições, o capitulo trabalhara em cima dos seguintes estudos:

\begin{itemize}
    \item On Modelling Virtual Machine Consolidation to
    Pseudo-Boolean Constraints \cite{bruno2012}
    \item PBFVMC: A New Pseudo-Boolean Formulation to Virtual-Machine Consolidation \cite{bruno2013}
    \item Um método de pré-processamento de fórmulas sat e pseudo-boolean baseado em tecnicas de programação linear inteira mista. \cite{bruno2015}
    \item Afinidades de tipos de aplicações em nuvens computacionais.\cite{fabio2014}
\end{itemize}

Os trabalhos citados a cima são divididos em duas formulações que visão encontrar uma decisão satisfatória para o problema em menor tempo hábil. Por esse motivo a estrutura desse capitulo contemplará uma primeira formulação vigente ao trabalho \cite{bruno2012} e apos isso sera analisado a evolução da formulação que se encontra no trabalho \cite{bruno2013}. 


\section{Primeira Formulação Pseudo Booleana}

Como explicado no tópico 3.3 sobre logica pseudo booleana, para representar um problema através dessa logica é necessário abstrair o problema em variáveis booleanas e disjunções de grandeza.

Na solução definida no artigo \cite{bruno2012} e definido seis conjuntos de restrições para minimizar o uso de maquinas ligadas, a obtenção dessas formulas foram feita através da abstração do problema e essas são:
 
 \subsection{Variáveis}

As variáveis boolianas definidas para restrições são hwi para representar o hardware onde 1 é quando a maquina esta ligada e 0 ela desligada.

Para a representação das maquinas virtuais foi feito uma representação diferente, onde cada variável possui sua representatividade e sua maquina designada, exemplo:

$$ vm_1^{ram \cdot hw2}$$

A variável do exemplo nesse contexto tem a representação a memoria ram da maquina virtual 1 rodando no hardware 2.

Desse modo a quantidade de variáveis do problema é $(N + K \cdot 2)$ sendo N a quantidade de hardware e K a quantidade de maquinas virtuais.
 
 \subsection{Formula Objetivo}
 
 A primeira formula definida diz respeito ao objetivo do problema que é minimizar o numero de maquinas físicas ligadas e matematicamente é expressa por: 
 
 $$[1] \qquad min: \sum_{i=1}^{n} hw_{i}$$	


 \subsection{Recurso Necessário Disponível}
 
 A segunda é terceira formula proposta diz respeito a verificação se a quantidade de ram e processamento das maquinas somadas se equivalem ao somatório da quantidade respectiva das maquinas virtuais. 

 $$[2] \qquad \sum_{i=1}^{n} RAM_{hwi} . hw_{i}^{ram} \geq \sum_{j=1}^{n} RAM_{vmj} \cdot vm_{j}^{ram} $$	


 $$[3] \qquad  \sum_{i=1}^{n} PROC_{hwi} . hw_{i}^{proc} \geq \sum_{j=1}^{n} PROC_{vmj} \cdot vm_{j}^{proc} $$	
 
 
 \subsection{Limitar Recurso por Hardware}

As duas clausulas definidas aqui diz respeito a limitação do uso do hardware pela maquinas virtuais, ela faz com que um hardware não etoure sua capacidade de alocar maquinas virtuais nele.  
 
 $$[4] \qquad \forall hw_{i}^{ram} \in hw_{n}^{ram} (\sum_{j = 1}^{k}  RAM_{vmj}
\cdot vm^{ram \cdot hwi}_{j} \leq RAM_{hwi})  $$

 $$ [5] \qquad  \forall hw_{i}^{proc} \in hw_{n}^{proc} (\sum_{j = 1}^{k}  PROC_{vmj}
\cdot vm^{proc \cdot hwi}_{j} \leq PROC_{hwi})  $$


\subsection{Uma Maquina Virtual por Harware}

A ultima restrição proposta é elaborada com o intuito de restringir o uso de uma Maquina virtual por hardware.

$$[6] \qquad \forall vm_{i} \in vm_{K} (\sum_{j = 1}^{n} vm_i^{proc \cdot hwj} \cdot vm_{i}^{ram \cdot hwj} \cdot hw_{j}^{proc} \cdot hw_{j}^{ram} = 1) $$
  
\subsection{Exemplo}

Nessa sub-seção sera mostrado um exemplo da construção das formulas da primeira formulação dado um conjunto de hardwares e maquinas virtuais.

Sendo estes:

\begin{table}[!htb]
    \caption{hardware e maquinas virtuais}
    \begin{minipage}{.5\linewidth}
      \caption{Hardware}
      \centering
        \begin{tabular}{ |c|c|c| } 
            \hline
            Nome & Ram & Processamento\\
            \hline
             hw1 & 100 & 20  \\ 
             hw2 & 30 & 10  \\ 

            \hline
        \end{tabular}
    \end{minipage}%
    \begin{minipage}{.5\linewidth}
      \centering
        \caption{Maquinas Virtuais}
        \begin{tabular}{ |c|c|c| } 
            \hline
            Nome & Ram & Processamento\\
            \hline
            vm1 & 50  & 5  \\ 
            vm2  & 30 & 20  \\ 
            vm3 & 10 & 5   \\
            \hline
        \end{tabular}
    \end{minipage} 
\end{table}

A partir desses dados geramos as restrições citadas anteriormente, onde para formula [1] temos:

    $$min: \quad hw1 + hw2 $$

para [2] e [3]:

    $$ 100 \cdot hw_1^{ram} + 30 \cdot hw_2^{ram} \geq 90$$

    $$ 20 \cdot hw_1^{proc} + 10 \cdot hw_2^{proc}  \geq 30$$
    

formula [4]:

$$ 50 \cdot vm_1^{ram \cdot hw1} + 30 \cdot vm_2^{ram \cdot hw1} + 10 \cdot vm_3^{ram \cdot hw1}\leq 100$$


$$ 50 \cdot vm_1^{ram \cdot hw2} + 30 \cdot vm_2^{ram \cdot hw2} + 10 \cdot vm_3^{ram \cdot hw2}\leq 30$$

formula [5]:

$$ 5 \cdot vm_1^{proc \cdot hw1} + 20 \cdot vm_2^{proc \cdot hw1} + 5 \cdot vm_3^{proc \cdot hw1}\leq 20$$


$$ 5 \cdot vm_1^{proc \cdot hw2} + 20 \cdot vm_2^{proc \cdot hw2} + 5 \cdot vm_3^{proc \cdot hw2}\leq 10$$

Formula [6]:


$$vm_1^{proc \cdot hw1} \cdot vm_{1}^{ram \cdot hw1} \cdot hw_{1}^{proc} \cdot hw_{1}^{ram} + vm_1^{proc \cdot hw2} \cdot vm_{1}^{ram \cdot hw2} \cdot hw_{2}^{proc} \cdot hw_{2}^{ram} = 1 $$


$$vm_2^{proc \cdot hw1} \cdot vm_{2}^{ram \cdot hw1} \cdot hw_{1}^{proc} \cdot hw_{1}^{ram} + vm_2^{proc \cdot hw2} \cdot vm_{2}^{ram \cdot hw2} \cdot hw_{2}^{proc} \cdot hw_{2}^{ram} = 1 $$


$$vm_3^{proc \cdot hw1} \cdot vm_{3}^{ram \cdot hw1} \cdot hw_{1}^{proc} \cdot hw_{1}^{ram} + vm_3^{proc \cdot hw2} \cdot vm_{3}^{ram \cdot hw2} \cdot hw_{2}^{proc} \cdot hw_{2}^{ram} = 1 $$

\section{Segunda Formulação Pseudo Booleana}

Essa seção visa mostrar a evolução da formulação anterior, onde foi utilizado mais restrições porem menos variáveis, o que se mostrou mais simples para a resolução.

\subsection{Variáveis}

As variáveis definidas na segunda formulação são hwi que continuam sendo as variáveis referente ao hardware, a variável $vm_j^{hwi}$ referente a maquina virtual  j rodando no hardware i e as variáveis N e K que são o numero total de hardware e de maquinas virtuais respectivamente.

Portanto o numero gerado de variáveis na formulação é $(N+N \cdot K) $ variáveis.



\subsection{Formula Objetivo}
 
 Como na abordagem da primeira formulação o principal objetivo é reduzir as maquinas virtuais ligada, e com isso a formula se manteve a mesma.

 $$[7] \qquad min: \sum_{i=1}^{n} hw_{i}$$	

\subsection{Acomodar recursos em hardwares ligados}

As duas formulas a seguir restringem que o somatório dos recursos dos hardwares ligados acomodem os recursos utilizados pela maquinas virtuais.

$$[8] \qquad \sum_{i=1}^{n} Ram_{hwi} \cdot hw_{i} \geq \sum_{j=1}^{k} Ram_{vmj} $$

$$[9] \qquad \sum_{i=1}^{n} Proc_{hwi} \cdot hw_{i} \geq \sum_{j=1}^{k} Proc_{vmj} $$

\subsection{Limites superiores}

As restriçoes a seguir di respeito ao quanto de recurso as maquinas podem prover as maquinas virtuais


$$[10] \qquad \forall i \in 1..n (\sum_{j=1}^{k} (Ram_{vmj} \cdot \lnot{vm_{j}^{hwi}}) + Rhw_{i} \cdot hw_i \geq \sum_{j=1}^{k} Ram_{vmj})$$

$$[11] \qquad \forall i \in 1..n (\sum_{j=1}^{k} (Proc_{vmj} \cdot \lnot{vm_{j}^{hwi}}) + Rhw_{i} \cdot hw_i \geq \sum_{j=1}^{k} Proc_{vmj})$$

\subsection{Alocação Obrigatoria}

Essa restrição define que cada maquina virtual deve esta alocada a um hardware.

$$[12] \qquad \forall i \in 1..n  \sum_{j=1}^{k} (vm_j^{hwi} \geq 1)$$

\subsection{Alocação unica}

E por fima ultima restrição garnte que uma maquina virtual possui alocação em apenas em um hardware, não podendo dividir os recursos da vm para distruibuir.

$$[13] \qquad \forall \quad j  \in 1..K (\sum_{i=1}^{N} \lnot{vm_j^{hwi}} \geq N - 1)$$

\subsection{Exemplo}

Nessa seção será mostrado a construção das formulas utilizando a segunda formulação, sera atribuído os mesmos valores do exemplo 3.2.5.

[7]

$$min: \quad hw1 + hw2 $$

[8] e [9]

$$100 \cdot hw_1 + 30 \cdot hw_2 \geq 90$$ 


$$20 \cdot hw_1 + 10 \cdot hw_2 \geq 30$$ 


[10] e [11]

$$ (50 \cdot \lnot{vm_1^{hw1}}) + (30  \cdot \lnot{vm_2^{hw1}}) + (10  \cdot \lnot{vm_3^{hw1}}) + 100 \cdot hw_1 \geq 90 $$ 

$$ (50 \cdot \lnot{vm_1^{hw2}}) + (30  \cdot \lnot{vm_2^{hw2}}) + (10  \cdot \lnot{vm_3^{hw2}}) + 30 \cdot hw_2 \geq 90 $$ 


$$ (5 \cdot \lnot{vm_1^{hw1}}) + (20  \cdot \lnot{vm_2^{hw1}}) + (5  \cdot \lnot{vm_3^{hw1}}) + 30 \cdot hw_1 \geq 30 $$ 


$$ (5 \cdot \lnot{vm_1^{hw2}}) + (20  \cdot \lnot{vm_2^{hw2}}) + (5  \cdot \lnot{vm_3^{hw2}}) + 30 \cdot hw_2 \geq 30 $$

[12]

$$ vm_1^{hw1} + vm_2^{hw1} + vm_3^{hw1} \geq 1 $$


$$ vm_1^{hw2} + vm_2^{hw2} + vm_3^{hw2} \geq 1 $$

[13]
 
$$ \lnot{vm_1^{hw1}} + \lnot{vm_1^{hw2}} \geq 1$$

$$ \lnot{vm_2^{hw1}} + \lnot{vm_2^{hw2}} \geq 1$$

$$ \lnot{vm_3^{hw1}} + \lnot{vm_3^{hw2}} \geq 1$$


\section{Afinidade de aplicações}

Essa seção visa trabalhar com as classes de aplicações e suas afinidades, seguindo o estudo afinidades de tipos de aplicações em nuvens computacionais \cite{fabio2014}.

Em detrimento de analisar aplicações e suas afinidades há a necessidade de um modo de diferenciar as aplicações existentes, para isso o estudo \cite{fabio2014} absorve para o seu trabalho a categorização de aplicações por classes  \textit{dwarfs}.

As classes dwarfs foram elaboradas com o fundamento de capturar o padrão de computação e comunicação de uma aplicação, essa classificação foi primeiramente vista no estudo \cite{colella2014} onde este divide os de aplicações em sete partes, e com a progressão do tempo o estudo foi expandido pela equipe de programação paralela de Berkeley para 13 categorias. \cite{asanovic2006}.

O estudo de afinidade do Licht é utilizado no trabalho realizado em Berkeley porem reduzindo os estudos para apenas 3 das categorias existentes, já que estes nos estudos apresentados essas classes se assemelham mais com a maioria das aplicações utilizadas em servidores, sendo essas:


\begin{itemize}


\item Grafo Transversal

Esse algoritmo é do tipo que realiza muitas visitas nos nós de um grafo, normalmente a execução desse algoritmo consome muita memoria ram.

\item Grade Estruturada

Esse algoritmo os dados são organizados em uma tabela regular, onde á o processamento de vários dados dessa tabela e a cada atualização da grade todos os pontos são atualizados.

\item Álgebra Linear Densa

Esse algoritmo faz operações com matrizes e vetores densos.

\end{itemize}

Para ilustrar melhor as aplicações e suas similaridades com as categorias pode ser visto através do gráfico abaixo, onde as cores indicam o grau de utilização sendo vermelho muito utilizado e azul de baixa utilização.

\includegraphics[]{aplicacaoDwarfs.png}

Outro ponto considerado no estudo é que quando as aplicações rodam juntos em uma maquina fisica há a necessidade da paralelização dos recursos, para que haja a optimização das aplicações, para isso o estudo voltou a estudar duas bibliotecas para esse fim muito utilizadas sendo elas as  OpenCL (Open Computing Language) e a OpenMP (Open Multi Processing).


Então a partir dos módulos específicos foram realizados os testes para as duas bibliotecas de programação paralela em ambiente real e virtualizado obtendo os resultados encontrados no anexo A, que são mostrados através da porcentagem de perda de desempenho do algoritmo.

Analisando ele pode se perceber que apesar do numero limitado de classes, a biblioteca de paralelização afeta também o resultado final, tornando um problema ainda mais complexo a afinidade entre algoritmos.


\begin{itemize}

\item LUD - Algebra Linear Densa

\item Kmeans - Álgebra Linear Densa

\item SRAD - Grade Estruturada

\item B+tree - Grafo Transversal

\end{itemize}

\chapter[Proposta]{Proposta}

A proposta levantada nessa etapa e que sera executada no trabalho de conclusão de curso 2 é uma tercerira evolução da formulação pseudo booleana apresentada anteriormente de modo que a solução se enquadre ainda mais no problema real encontrado no gerenciamento da alocação de maquinas virtuais.

Na modelagem atual a formulação faz a optimização considerando apenas alocação das maquinas por quantidade de cpu e memoria ram, porem essa abordagem considerando apenas isso desconsidera uma possibilidade que ocorre no mundo real de concorrência entre maquinas virtuais.

Para acoplar a afinidade de classe e por sua vez adequá ao problema real, é visado para segunda parte desse projeto adicionar a formulação logicas que referenciem as classes dwarfs é as bibliotecas de paralelização.

Portanto é esperado que ao estender a formulação seja possível manter o padrão que a segunda formulação traz de minimizar os equipamentos ligados, porem evitando conflitos com aplicações com baixa afinidade.

Para a conclusão no projeto em sua totalidade é esperado que as seguintes perguntas sejam respondidas:

\begin{itemize}
    \item A solução tem aplicabilidade real ?
    \item Qual o custo do algoritmo ?
    \item Quais métricas devem ser consideradas para determinar se o tempo do algoritmo é viável ?
    \item O algoritmo possui um ponto onde deixa de compensar ?
    \item O algoritmo pode ser melhorado ? 
    \item As restrições da segunda formulação pode ser aprimoradas ?
    \item É necessário acrescentar novas restrições ou um pre-processamento dos dados resolve o problema ?  
\end{itemize}


\chapter{Planejamento}

Esse capitulo tem o proposito de explicar como será feito o desenvolvimento do TCC 2, ilustrando suas etapas e o cronograma para ser realizado essas atividades.  

\section{Etapas do Projeto}

Para a execução de um bom projeto é necessário obter consistência no desenvolvimento do mesmo, para isso é importante definir etapas para o workflow do mesmo, porem é importante ressaltar que a boa definição de um processo de desenvolvimento não garante que o algoritmo seja efetivo e sim que o estudos feitos em cima do problema foram. 


\subsection{Estudo e Planejamento}

Essa etapa é destinada para um estudo de possíveis hipóteses para a nova formulação, ao sair dessa etapa não há a necessidade de uma formulação bem estruturada e sim uma lista de prováveis ideias para a formulação para serem executadas.

\subsection{Preparação dos dados}

Essa etapa é a menor da listadas, ela tem o objetivo de preparar dados para os testes a serem realizados.

\subsection{Ciclo de Formulação e testes}
    
Nessa etapa as hipóteses formuladas serão consolidadas através das restrições e testadas com os dados fornecidos, descartando formulações que se mostrem sem progressão e aprimorando as melhores.

Essa etapa é vista como um ciclo pois é baseada em formulação e testes que tende a se aperfeiçoar através de interações onde o ciclo tem sua finalização més que antecedem a entrega do trabalho.
    
\subsubsection{Avaliação e Comparativo}

A ultima etapa, e que conclui o trabalho, é a analise dos resultados obtidos, o viés dessa etapa é chegar a conclusão sobre a formulação final e seu desenvolvimento, discorrendo sobre fatos pertinentes no projeto através de métricas que também serão definidas nessa etapa.

É esperado que nessa essa etapa sejam respondidas as perguntas definidas na proposta, concluindo assim o projeto.


\section[Cronograma]{Cronograma}
\begin{table}[!htb]
    \centering
    \caption{Cronograma}
    \begin{tabular}{ |c|c|c| } 
        \hline
        Atividade & Data de Inicio & Data Fim\\
        \hline
        Estudo e Planejamento & 12/07/2019 & 12/08/2019  \\
        Preparação dos dados & 12/07/2019 & 19/08/2019  \\
        Ciclo de Formulação e testes & 19/08/2019 & 25/11/2019 \\
        Avaliação e Comparativo & 25/11/2019 & 01/11/2019 \\
        Conclusão e Apresentação do Trabalho & 01/12/2019 & 10/12/2019  \\
        Fim do Semestre & 10/12/2019 & --  \\ 
        \hline
    \end{tabular}
\end{table}